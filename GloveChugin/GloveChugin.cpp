//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>

#include <fcntl.h>
#include <termios.h>
#include <unistd.h>

#include <iostream>

// declaration of chugin constructor
CK_DLL_CTOR(glovechugin_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(glovechugin_dtor);

CK_DLL_MFUN(glovechugin_connect);
CK_DLL_MFUN(glovechugin_close);
CK_DLL_MFUN(glovechugin_getMessage);

// this is a special offset reserved for Chugin internal data
t_CKINT glovechugin_data_offset = 0;

#define MESSAGE_LENGTH 50

// TODO, won't work when we want multiple Bluetooth devices!
// doing this for now because Chuck_String->str seems to have
// crazy corrupt garbage in it...
const char * HARDCODED_DEVICE_PATH = "/dev/tty.usbserial-FTE3RR3T";

// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class GloveChugin
{
public:
    // constructor
    GloveChugin()
    {
	reading_offset = 0;
    }

    ~GloveChugin()
    {
    }

    void connect(const char * path_str) {
        std::cerr << "STRING " << path_str << std::endl;

	int m_fd = open(path_str, O_RDWR | O_NOCTTY | O_NDELAY);
	if (m_fd < 0) {
            fprintf(stderr, "CANT OPEN PATH %s\n", path_str);
	    return;
	}

	struct termios toptions;
	tcgetattr(m_fd, &toptions);
	cfsetispeed(&toptions, B115200);
	cfsetospeed(&toptions, B115200);

	// 8 bits per character
	toptions.c_cflag &= ~CSIZE;
	toptions.c_cflag |= CS8;

	toptions.c_cflag &= ~PARENB; // no parity
	toptions.c_cflag &= ~CSTOPB; // one stop bit

	toptions.c_cflag &= ~CRTSCTS; // No hardwre flow control
	toptions.c_cflag |= CREAD; // Enable read
	toptions.c_cflag |= CLOCAL; // ignore modem control lines

	toptions.c_iflag &= ~(IXON | IXOFF | IXANY); // No flow control
	toptions.c_iflag &= ~(ICANON | ECHO | ECHOE | ISIG); // No echo, not in canonical mode

	toptions.c_oflag &= ~OPOST; // No output processing

	toptions.c_cc[VMIN] = 24; // Buffer at least 24 characters before returning from read
	toptions.c_cc[VTIME] = 1; // OR return from read after 0.1 second of silence

	// Drop everything that has happened, start fresh
	tcsetattr(m_fd, TCSAFLUSH, &toptions);

	// TODO TEMPORARY
	usleep(1000*1000);
	printf("Attempting read\n");
        size_t bytes_read = read(m_fd, m_reading_buffer, sizeof(m_reading_buffer));
	printf("Read %lu bytes\n", bytes_read);

        ::close(m_fd);
    }

    void close() {
	;
    }

    // fill array with message
    void getMessage(Chuck_Array4 *messageHolder) {
	; // FILL THIS IN!
    }
    
private:
    // instance data
    int m_fd;
    unsigned char m_reading_buffer[MESSAGE_LENGTH];
    unsigned char m_ready_buffer[MESSAGE_LENGTH];
    size_t reading_offset;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( GloveChugin )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "GloveChugin");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "GloveChugin", "Object");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, glovechugin_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, glovechugin_dtor);

    QUERY->add_mfun(QUERY, glovechugin_connect, "void", "connect");
    QUERY->add_arg(QUERY, "string", "devicePath");

    QUERY->add_mfun(QUERY, glovechugin_close, "void", "close");

    // example of adding setter method
    QUERY->add_mfun(QUERY, glovechugin_getMessage, "void", "getMessage");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "int[]", "arg");
    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    glovechugin_data_offset = QUERY->add_mvar(QUERY, "int", "@gc_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}

// implementation for the constructor
CK_DLL_CTOR(glovechugin_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, glovechugin_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    GloveChugin * bcdata = new GloveChugin();
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, glovechugin_data_offset) = (t_CKINT) bcdata;
}


// implementation for the destructor
CK_DLL_DTOR(glovechugin_dtor)
{
    // get our c++ class pointer
    GloveChugin * bcdata = (GloveChugin *) OBJ_MEMBER_INT(SELF, glovechugin_data_offset);
    // check it
    if( bcdata )
    {
        // clean up
        delete bcdata;
        OBJ_MEMBER_INT(SELF, glovechugin_data_offset) = 0;
        bcdata = NULL;
    }
}

CK_DLL_MFUN(glovechugin_connect)
{
    GloveChugin * bcdata = (GloveChugin *) OBJ_MEMBER_INT(SELF, glovechugin_data_offset);

    // TODO- why does deviceName->str point to garbage?
    Chuck_String * deviceName = GET_NEXT_STRING(ARGS);
    printf("Got input device name %s\n", deviceName->str.c_str());

    // bcdata->connect(deviceName->str.c_str());
    bcdata->connect(HARDCODED_DEVICE_PATH);
}

CK_DLL_MFUN(glovechugin_close)
{
    GloveChugin * bcdata = (GloveChugin *) OBJ_MEMBER_INT(SELF, glovechugin_data_offset);
    bcdata->close();
}

CK_DLL_MFUN(glovechugin_getMessage)
{
    GloveChugin * bcdata = (GloveChugin *) OBJ_MEMBER_INT(SELF, glovechugin_data_offset);
    Chuck_Array4 * outArray = (Chuck_Array4 *) GET_NEXT_OBJECT(ARGS);
    bcdata->getMessage(outArray);
}
